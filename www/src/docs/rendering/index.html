<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta name="description" content="Documentation for the Thunderous library." />
		<meta property="og:image" content="/meta.png" />
		<meta name="twitter:image" content="/meta.png" />
		<title>Rendering | Thunderous</title>
		<link rel="stylesheet" href="/global.css" />
		<link rel="favicon" href="/favicon.ico" />
	</head>
	<body>
		<th-doc-page>
			<th-page-header>Rendering</th-page-header>
			<th-content-group>
				<th-text>
					For rendering, Thunderous exports a tagged template literal function called <th-code>html``</th-code>. This
					doesn't create a virtual DOM, but instead it directly converts an HTML string into a native
					<th-code>DocumentFragment</th-code> that can be appended to the DOM. Additionally, it enables template binding
					with <th-link href="/docs/event-binding">event listeners</th-link> and
					<th-link href="/docs/binding-signals">signals</th-link>.
				</th-text>
				<th-block-quote>
					Note that Thunderous does not sanitize the input of the <th-code>html``</th-code> function. It is up to the
					developer to ensure that the input is safe to render. Please use a package like
					<th-link href="https://github.com/cure53/DOMPurify">DOMPurify</th-link> or similar to sanitize any dangerous
					input.
				</th-block-quote>
				<th-text>
					It's important to remember that Thunderous will only run the component function once, when the custom element
					gets upgraded. This is different from other libraries that re-render the component on every state change.
					Instead, Thunderous relies on signals to make fine-grained updates to the DOM when the state changes, but more
					on that later.
				</th-text>
				<th-text>
					For conditionals, you can easily render nested templates with the <th-code>html``</th-code> function.
				</th-text>
				<th-code-block lang="ts"><%= include('_code-snippets/render-nested.ejs') %></th-code-block>
				<th-block-quote>
					Short-circuit evaluation is not recommended because <th-code>false</th-code> values may be rendered as text.
					Ternaries are generally a better choice for conditionals, as they provide more explicit control over the
					rendered output. That said, <th-code>null</th-code> or <th-code>undefined</th-code> will render nothing.
				</th-block-quote>
				<th-text>
					For loops, you can map an array to a list of <th-code>DocumentFragment</th-code> objects. Each element should
					have a unique <th-code>key</th-code> attribute to help Thunderous keep track of the items in the list.
				</th-text>
				<th-code-block lang="ts"><%= include('_code-snippets/render-loops.ejs') %></th-code-block>
				<th-text>
					To render a reactive template, you can use <th-code>computed()</th-code> signals. This will hand off the signal
					to <th-code>html``</th-code>, which will then update the DOM when the signals change.
				</th-text>
				<th-block-quote>
					For more information on signals, see the <th-link href="/docs/signals">signals overview</th-link> and
					<th-link href="/docs/computed-signals">computed signals</th-link> documentation.
				</th-block-quote>
				<th-code-block lang="ts"><%= include('_code-snippets/render-reactive.ejs') %></th-code-block>
				<th-text>
					In the same way, you can use <th-code>computed()</th-code> to render reactive attribute values.
				</th-text>
				<th-code-block lang="ts"><%= include('_code-snippets/render-reactive-attr.ejs') %></th-code-block>
			</th-content-group>
		</th-doc-page>
		<script type="module" src="/main.ts"></script>
	</body>
</html>
